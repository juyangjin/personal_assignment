## 1. week2-3_계산기 만들기
### 1-1. 기본과제
<details>
<summary>Lv 1</summary>
  
  ### Lv 1. 클래스 없이 기본적인 연산을 수행할 수 있는 계산기 만들기
- **양의 정수(0 포함)를 입력받기**
- **사칙연산 기호(➕,➖,✖️,➗)를 입력받기**
- **위에서 입력받은 양의 정수 2개와 사칙연산 기호를 사용하여 연산을 진행한 후 결과값을 출력하기**
- **반복문을 사용하되, 반복의 종료를 알려주는 “exit” 문자열을 입력하기 전까지 무한으로 계산을 진행할 수 있도록 소스 코드를 수정하기**

  - 첫번째인지 여부를 확인하는 f변수, 두 정수 one과 two, 그리고 종료의 여부를 확인하는 ex변수를 먼저 선언 및 초기화
  - 무한반복을 위해 while(true)를 사용, 적절한 조건에서 종료하기 위해 while 앞에 A :를 지정
  - 먼저 f값(0으로 초기화된 값)이 1인지 0인지 판단하여 0인 처음엔 else if 문이 실행
양의 정수 두 개를 각각 한 줄로 입력받고 양의 값들이 음수인지 판별
  - 음수라면 잘못 입력되어 프로그램이 종료되고 첫번째가 종료되었다는 의미로 f에 1이 저장
  - 제대로 입력 받았다면 입력반은 정수 값들이 무엇인지 출력되고 연산자를 입력하라는 메시지가 출력   - 연산자 +,-,*,/ 넷 중에 맞는 값이 없다면 잘못 입력되었다는 예외처리 문구가 출력되며 f에 1이 저장
  -  답을 저장할 변수 result도 연산자를 받은 후에 0으로 초기화
  - 연산자가 제대로 작동할 경우 연산된 값은 result에 알맞게 저장되고 one (연산자) two = result 형태로 출력, 마지막 조건문까지 전부 돌아가면 마지막에 또 f에 1이 저장
  - 첫번째 코드가 종료되고 다시 첫번째 줄로 돌아왔을 때 if 문에 f는 1이므로 계산을 더 하겠냐는 문구와 exit를 입력하여 종료가 가능하다는 문구 생성 이 때 마지막 종료 조건에서 ex 값이 스캔되지 않은 상태에서 넘어가서 else가 작동되고 f가 다시 0으로 돌아가면서 1번으로 다시 되돌아가는 문제가 발생
  - 해결 방법은 ex로 nextLine을 스캔받기 전에 tmp 변수를 둬서 한 번 nextLine()을 먼저 구동해서 해결

- **자세한 코드 해설은 [계산기 만들기 (1)](https://velog.io/@wndid2008/TIL%EA%B3%84%EC%82%B0%EA%B8%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-1)에서도 확인할 수 있습니다.**
</details>

<details>
<summary>Lv 2</summary>  
  
### Lv 2. 클래스를 적용해 기본적인 연산을 수행할 수 있는 계산기 만들기
- **Lv 1에서 구현한 App 클래스의 main 메서드에 Calculator 클래스가 활용될 수 있도록 수정**
- **App 클래스의 main 메서드에서 Calculator 클래스의 연산 결과를 저장하고 있는 컬렉션 필드에 직접 접근하지 못하도록 수정 (캡슐화)**

  - CalculatorApp 에서 Parser 클래스의 메서드(매개변수) 호출
  - Parser에서 매개변수가 특정 패턴에서 벗어난다면 예외문구가 출력되고 아니라면 해당 변수의 자료형과 동일한 자료형으로 Calculator 클래스의 참조형 메서드를 이용하여 해당 값을 삽입
  - Parser 클래스에서 연산자에 따라 다른 결과를 switch case 문으로 작성하는데 이 때 Calculator 클래스의 참조형 메서드를 이용하여 연산자 클래스를 호출
  - 연산자 클래스는 추상화가 되어있는 상태이므로 모두 이름이 동일하지만 오버라이딩 되어 각기 다른 결괏값을 리턴
  - Parser 클래스에서 executeCalculator() 메서드로 Calculator 클래스의 calculate() 메서드를 호출
  - calculate() 메서드에서 추상클래스를 접근시키는데 이 때 setOperation 메서드에서 this.operation = operation; 이라는 구문으로 operation 인스턴스가 접근하는 것이 어떤 연산자 클래스인지 구분이 된 상태이므로 해당 연산자로 값이 계산되어 리턴
  - CalculatorApp 에서 최종 결과 출력

- **자세한 코드 해설은 [계산기 만들기 (2)](https://velog.io/@wndid2008/TIL-%EA%B3%84%EC%82%B0%EA%B8%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-2-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-Error)에서도 확인할 수 있습니다.**
</details>

### 1-2. 도전과제
<details>
<summary>Lv 3</summary>  

### 3. Enum, 제네릭, 람다 & 스트림을 이해한 계산기 만들기
- **현재 사칙연산 계산기는 (➕,➖,✖️,➗) 이렇게 총 4가지 연산 타입으로 구성되어 있습니다.**
- **실수, 즉 double 타입의 값을 전달 받아도 연산이 수행하도록 만들기**
- **저장된 연산 결과들 중 Scanner로 입력받은 값보다 큰 결과값 들을 출력**

  - 기존 Queue 기능을 유지하면서 추상클래스를 아예 인터페이스로 변경
  - 제네릭을 사용하여 연산자 클래스에서 개별적으로 형변환 후 사용
  - Parser클래스에서 Enum을 추가하여 스위치문 구성
  - Enum은 연산자 클래스에 대한 생성자로 각각 설정
  - Main에서 Queue에 저장된 값과 현재 입력되어 연산된 값을 비교하는 if-else문을 추가하여 현재 연산된 값보다 큰 값만 출력 

- **자세한 코드 해설은 [계산기 만들기 (3)](https://velog.io/@wndid2008/TIL-%EA%B3%84%EC%82%B0%EA%B8%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-3)와 [계산기 만들기 (3)-최종](https://velog.io/@wndid2008/TIL-%EA%B3%84%EC%82%B0%EA%B8%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-3-%EC%B5%9C%EC%A2%85)에서도 확인할 수 있습니다.**

</details>

